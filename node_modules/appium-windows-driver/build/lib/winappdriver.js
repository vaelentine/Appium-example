"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WinAppDriver = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _appiumBaseDriver = require("appium-base-driver");

var _logger = _interopRequireDefault(require("./logger"));

var _teen_process = require("teen_process");

var _installer = require("./installer");

var _asyncbox = require("asyncbox");

var _child_process = require("child_process");

var _appiumSupport = require("appium-support");

var _portscanner = require("portscanner");

const DEFAULT_BASE = '/wd/hub';
const DEFAULT_HOST = '127.0.0.1';
const WAD_PORT_RANGE = [4724, 4824];
const STARTUP_TIMEOUT_MS = 10000;
const DEFAULT_CREATE_SESSION_TIMEOUT_MS = 20000;

const PORT_ALLOCATION_GUARD = _appiumSupport.util.getLockFileGuard(_path.default.resolve(_os.default.tmpdir(), 'wad_port_guard'), {
  timeout: 5,
  tryRecovery: true
});

class WADProxy extends _appiumBaseDriver.JWProxy {
  async proxyCommand(url, method, body = null) {
    if (this.didProcessExit) {
      throw new _appiumBaseDriver.errors.InvalidContextError(`'${method} ${url}' cannot be proxied to WinAppDriver server because ` + 'its process is not running (probably crashed). Check the Appium log for more details');
    }

    return await super.proxyCommand(url, method, body);
  }

}

class WADProcess {
  constructor(opts = {}) {
    this.base = opts.base;
    this.port = opts.port;
    this.executablePath = opts.executablePath;
    this.proc = null;
  }

  get isRunning() {
    var _this$proc;

    return !!((_this$proc = this.proc) !== null && _this$proc !== void 0 && _this$proc.isRunning);
  }

  async start() {
    if (this.isRunning) {
      return;
    }

    if (!this.port) {
      await PORT_ALLOCATION_GUARD(async () => {
        const [startPort, endPort] = WAD_PORT_RANGE;

        try {
          this.port = await (0, _portscanner.findAPortNotInUse)(startPort, endPort);
        } catch (e) {
          _logger.default.errorAndThrow(`Could not find any free port in range ${startPort}..${endPort}. ` + `Please check your system firewall settings or set 'systemPort' capability ` + `to the desired port number`);
        }
      });
    }

    const args = [`${this.port}${this.base}`];
    this.proc = new _teen_process.SubProcess(this.executablePath, args, {
      encoding: 'ucs2'
    });
    this.proc.on('output', (stdout, stderr) => {
      const line = _lodash.default.trim(stderr || stdout);

      if (line) {
        _logger.default.debug(line);
      }
    });
    this.proc.on('exit', (code, signal) => {
      _logger.default.info(`WinAppDriver exited with code ${code}, signal ${signal}`);
    });

    _logger.default.info(`Spawning '${this.executablePath}' with args: ${JSON.stringify(args)}`);

    await this.proc.start(0);
  }

  async stop() {
    if (this.isRunning) {
      try {
        await this.proc.stop();
      } catch (e) {
        _logger.default.warn(`WinAppDriver process with PID ${this.proc.pid} cannot be stopped. ` + `Original error: ${e.message}`);
      }
    }
  }

}

const RUNNING_PROCESS_IDS = [];
process.once('exit', () => {
  for (const pid of RUNNING_PROCESS_IDS) {
    const command = `taskkill.exe /PID ${pid}`;

    try {
      (0, _child_process.execSync)(command);
    } catch (e) {
      _logger.default.warn(`WinAppDriver process with PID ${pid} cannot be cleaned up. ` + `Original error: ${e.message}`);
    }
  }
});

class WinAppDriver {
  constructor(opts = {}) {
    this.proxyPort = opts.port;
    this.process = null;
    this.proxy = null;
  }

  async start(caps) {
    const executablePath = await (0, _installer.getWADExecutablePath)();
    this.process = new WADProcess({
      base: DEFAULT_BASE,
      port: this.proxyPort,
      executablePath
    });
    await this.process.start();
    this.proxy = new WADProxy({
      server: DEFAULT_HOST,
      port: this.process.port
    });
    this.proxy.didProcessExit = false;
    this.process.proc.on('exit', () => {
      this.proxy.didProcessExit = true;
    });

    try {
      await (0, _asyncbox.waitForCondition)(async () => {
        try {
          await this.proxy.command('/status', 'GET');
          return true;
        } catch (err) {
          if (this.proxy.didProcessExit) {
            throw new Error(err.message);
          }

          return false;
        }
      }, {
        waitMs: STARTUP_TIMEOUT_MS,
        intervalMs: 1000
      });
    } catch (e) {
      if (/Condition unmet/.test(e.message)) {
        throw new Error(`WinAppDriver server is not listening within ${STARTUP_TIMEOUT_MS}ms timeout. ` + `Make sure it could be started manually`);
      }

      throw e;
    }

    const pid = this.process.proc.pid;
    RUNNING_PROCESS_IDS.push(pid);
    this.process.proc.on('exit', () => void _lodash.default.pull(RUNNING_PROCESS_IDS, pid));
    await this._startSession(caps);
  }

  async _startSession(desiredCapabilities) {
    const {
      createSessionTimeout = DEFAULT_CREATE_SESSION_TIMEOUT_MS
    } = desiredCapabilities;

    _logger.default.debug(`Starting WinAppDriver session. Will timeout in '${createSessionTimeout}' ms.`);

    let retryIteration = 0;
    let lastError;

    const condFn = async () => {
      lastError = null;
      retryIteration++;

      try {
        await this.proxy.command('/session', 'POST', {
          desiredCapabilities
        });
        return true;
      } catch (error) {
        lastError = error;

        _logger.default.warn(`Could not start WinAppDriver session error = '${error.message}', attempt = '${retryIteration}' from '${this.createSessionRetry}'`);

        return false;
      }
    };

    try {
      await (0, _asyncbox.waitForCondition)(condFn, {
        waitMs: createSessionTimeout,
        intervalMs: 500
      });
    } catch (timeoutError) {
      _logger.default.debug(`timeoutError was ${timeoutError.message}`);

      if (lastError) {
        throw lastError;
      }

      throw new Error(`Could not start WinAppDriver session within ${createSessionTimeout} ms.`);
    }
  }

  async stop() {
    var _this$process, _this$proxy;

    if (!((_this$process = this.process) !== null && _this$process !== void 0 && _this$process.isRunning)) {
      return;
    }

    if ((_this$proxy = this.proxy) !== null && _this$proxy !== void 0 && _this$proxy.sessionId) {
      _logger.default.debug('Deleting WinAppDriver server session');

      try {
        var _this$proxy2;

        await this.proxy.command(`/session/${(_this$proxy2 = this.proxy) === null || _this$proxy2 === void 0 ? void 0 : _this$proxy2.sessionId}`, 'DELETE');
      } catch (err) {
        _logger.default.warn(`Did not get confirmation WinAppDriver deleteSession worked; ` + `Error was: ${err.message}`);
      }
    }

    await this.process.stop();
  }

  async sendCommand(url, method, body) {
    return await this.proxy.command(url, method, body);
  }

}

exports.WinAppDriver = WinAppDriver;
var _default = WinAppDriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93aW5hcHBkcml2ZXIuanMiXSwibmFtZXMiOlsiREVGQVVMVF9CQVNFIiwiREVGQVVMVF9IT1NUIiwiV0FEX1BPUlRfUkFOR0UiLCJTVEFSVFVQX1RJTUVPVVRfTVMiLCJERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVMiLCJQT1JUX0FMTE9DQVRJT05fR1VBUkQiLCJ1dGlsIiwiZ2V0TG9ja0ZpbGVHdWFyZCIsInBhdGgiLCJyZXNvbHZlIiwib3MiLCJ0bXBkaXIiLCJ0aW1lb3V0IiwidHJ5UmVjb3ZlcnkiLCJXQURQcm94eSIsIkpXUHJveHkiLCJwcm94eUNvbW1hbmQiLCJ1cmwiLCJtZXRob2QiLCJib2R5IiwiZGlkUHJvY2Vzc0V4aXQiLCJlcnJvcnMiLCJJbnZhbGlkQ29udGV4dEVycm9yIiwiV0FEUHJvY2VzcyIsImNvbnN0cnVjdG9yIiwib3B0cyIsImJhc2UiLCJwb3J0IiwiZXhlY3V0YWJsZVBhdGgiLCJwcm9jIiwiaXNSdW5uaW5nIiwic3RhcnQiLCJzdGFydFBvcnQiLCJlbmRQb3J0IiwiZSIsImxvZyIsImVycm9yQW5kVGhyb3ciLCJhcmdzIiwiU3ViUHJvY2VzcyIsImVuY29kaW5nIiwib24iLCJzdGRvdXQiLCJzdGRlcnIiLCJsaW5lIiwiXyIsInRyaW0iLCJkZWJ1ZyIsImNvZGUiLCJzaWduYWwiLCJpbmZvIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0b3AiLCJ3YXJuIiwicGlkIiwibWVzc2FnZSIsIlJVTk5JTkdfUFJPQ0VTU19JRFMiLCJwcm9jZXNzIiwib25jZSIsImNvbW1hbmQiLCJXaW5BcHBEcml2ZXIiLCJwcm94eVBvcnQiLCJwcm94eSIsImNhcHMiLCJzZXJ2ZXIiLCJlcnIiLCJFcnJvciIsIndhaXRNcyIsImludGVydmFsTXMiLCJ0ZXN0IiwicHVzaCIsInB1bGwiLCJfc3RhcnRTZXNzaW9uIiwiZGVzaXJlZENhcGFiaWxpdGllcyIsImNyZWF0ZVNlc3Npb25UaW1lb3V0IiwicmV0cnlJdGVyYXRpb24iLCJsYXN0RXJyb3IiLCJjb25kRm4iLCJlcnJvciIsImNyZWF0ZVNlc3Npb25SZXRyeSIsInRpbWVvdXRFcnJvciIsInNlc3Npb25JZCIsInNlbmRDb21tYW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLFlBQVksR0FBRyxTQUFyQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxXQUFyQjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQXZCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsS0FBM0I7QUFDQSxNQUFNQyxpQ0FBaUMsR0FBRyxLQUExQzs7QUFHQSxNQUFNQyxxQkFBcUIsR0FBR0Msb0JBQUtDLGdCQUFMLENBQXNCQyxjQUFLQyxPQUFMLENBQWFDLFlBQUdDLE1BQUgsRUFBYixFQUEwQixnQkFBMUIsQ0FBdEIsRUFBbUU7QUFDL0ZDLEVBQUFBLE9BQU8sRUFBRSxDQURzRjtBQUUvRkMsRUFBQUEsV0FBVyxFQUFFO0FBRmtGLENBQW5FLENBQTlCOztBQUtBLE1BQU1DLFFBQU4sU0FBdUJDLHlCQUF2QixDQUErQjtBQUNYLFFBQVpDLFlBQVksQ0FBRUMsR0FBRixFQUFPQyxNQUFQLEVBQWVDLElBQUksR0FBRyxJQUF0QixFQUE0QjtBQUM1QyxRQUFJLEtBQUtDLGNBQVQsRUFBeUI7QUFDdkIsWUFBTSxJQUFJQyx5QkFBT0MsbUJBQVgsQ0FDSCxJQUFHSixNQUFPLElBQUdELEdBQUkscURBQWxCLEdBQ0Esc0ZBRkksQ0FBTjtBQUdEOztBQUNELFdBQU8sTUFBTSxNQUFNRCxZQUFOLENBQW1CQyxHQUFuQixFQUF3QkMsTUFBeEIsRUFBZ0NDLElBQWhDLENBQWI7QUFDRDs7QUFSNEI7O0FBVy9CLE1BQU1JLFVBQU4sQ0FBaUI7QUFDZkMsRUFBQUEsV0FBVyxDQUFFQyxJQUFJLEdBQUcsRUFBVCxFQUFhO0FBQ3RCLFNBQUtDLElBQUwsR0FBWUQs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LEdBQVAsRUFBWTtBQUNaOUIsd0JBQUlrQixJQUFKLENBQVUsOERBQUQsR0FDTixjQUFhWSxHQUFHLENBQUNWLE9BQVEsRUFENUI7QUFFRDtBQUNGOztBQUVELFVBQU0sS0FBS0UsT0FBTCxDQUFhTCxJQUFiLEVBQU47QUFDRDs7QUFFZ0IsUUFBWDhCLFdBQVcsQ0FBRWpFLEdBQUYsRUFBT0MsTUFBUCxFQUFlQyxJQUFmLEVBQXFCO0FBQ3BDLFdBQU8sTUFBTSxLQUFLMkMsS0FBTCxDQUFXSCxPQUFYLENBQW1CMUMsR0FBbkIsRUFBd0JDLE1BQXhCLEVBQWdDQyxJQUFoQyxDQUFiO0FBQ0Q7O0FBaEhnQjs7O2VBb0hKeUMsWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBKV1Byb3h5LCBlcnJvcnMgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IGdldFdBREV4ZWN1dGFibGVQYXRoIH0gZnJvbSAnLi9pbnN0YWxsZXInO1xuaW1wb3J0IHsgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgZmluZEFQb3J0Tm90SW5Vc2UgfSBmcm9tICdwb3J0c2Nhbm5lcic7XG5cblxuY29uc3QgREVGQVVMVF9CQVNFID0gJy93ZC9odWInO1xuY29uc3QgREVGQVVMVF9IT1NUID0gJzEyNy4wLjAuMSc7XG5jb25zdCBXQURfUE9SVF9SQU5HRSA9IFs0NzI0LCA0ODI0XTtcbmNvbnN0IFNUQVJUVVBfVElNRU9VVF9NUyA9IDEwMDAwO1xuY29uc3QgREVGQVVMVF9DUkVBVEVfU0VTU0lPTl9USU1FT1VUX01TID0gMjAwMDA7IC8vIHJldHJ5IHN0YXJ0IHNlc3Npb24gY3JlYXRpb24gZHVyaW5nIHRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuLy8gVGhlIGd1YXJkIGlzIG5lZWRlZCB0byBhdm9pZCBkeW5hbWljIHN5c3RlbSBwb3J0IGFsbG9jYXRpb24gY29uZmxpY3RzIGZvclxuLy8gcGFyYWxsZWwgZHJpdmVyIHNlc3Npb25zXG5jb25zdCBQT1JUX0FMTE9DQVRJT05fR1VBUkQgPSB1dGlsLmdldExvY2tGaWxlR3VhcmQocGF0aC5yZXNvbHZlKG9zLnRtcGRpcigpLCAnd2FkX3BvcnRfZ3VhcmQnKSwge1xuICB0aW1lb3V0OiA1LFxuICB0cnlSZWNvdmVyeTogdHJ1ZSxcbn0pO1xuXG5jbGFzcyBXQURQcm94eSBleHRlbmRzIEpXUHJveHkge1xuICBhc3luYyBwcm94eUNvbW1hbmQgKHVybCwgbWV0aG9kLCBib2R5ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmRpZFByb2Nlc3NFeGl0KSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRDb250ZXh0RXJyb3IoXG4gICAgICAgIGAnJHttZXRob2R9ICR7dXJsfScgY2Fubm90IGJlIHByb3hpZWQgdG8gV2luQXBwRHJpdmVyIHNlcnZlciBiZWNhdXNlIGAgK1xuICAgICAgICAnaXRzIHByb2Nlc3MgaXMgbm90IHJ1bm5pbmcgKHByb2JhYmx5IGNyYXNoZWQpLiBDaGVjayB0aGUgQXBwaXVtIGxvZyBmb3IgbW9yZSBkZXRhaWxzJyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdXBlci5wcm94eUNvbW1hbmQodXJsLCBtZXRob2QsIGJvZHkpO1xuICB9XG59XG5cbmNsYXNzIFdBRFByb2Nlc3Mge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5iYXNlID0gb3B0cy5iYXNlO1xuICAgIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgICB0aGlzLmV4ZWN1dGFibGVQYXRoID0gb3B0cy5leGVjdXRhYmxlUGF0aDtcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlzUnVubmluZyAoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMucHJvYz8uaXNSdW5uaW5nKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucG9ydCkge1xuICAgICAgYXdhaXQgUE9SVF9BTExPQ0FUSU9OX0dVQVJEKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgW3N0YXJ0UG9ydCwgZW5kUG9ydF0gPSBXQURfUE9SVF9SQU5HRTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnBvcnQgPSBhd2FpdCBmaW5kQVBvcnROb3RJblVzZShzdGFydFBvcnQsIGVuZFBvcnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coXG4gICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgYW55IGZyZWUgcG9ydCBpbiByYW5nZSAke3N0YXJ0UG9ydH0uLiR7ZW5kUG9ydH0uIGAgK1xuICAgICAgICAgICAgYFBsZWFzZSBjaGVjayB5b3VyIHN5c3RlbSBmaXJld2FsbCBzZXR0aW5ncyBvciBzZXQgJ3N5c3RlbVBvcnQnIGNhcGFiaWxpdHkgYCArXG4gICAgICAgICAgICBgdG8gdGhlIGRlc2lyZWQgcG9ydCBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtgJHt0aGlzLnBvcnR9JHt0aGlzLmJhc2V9YF07XG4gICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3ModGhpcy5leGVjdXRhYmxlUGF0aCwgYXJncywge1xuICAgICAgZW5jb2Rpbmc6ICd1Y3MyJ1xuICAgIH0pO1xuICAgIHRoaXMucHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gXy50cmltKHN0ZGVyciB8fCBzdGRvdXQpO1xuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGxpbmUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgIGxvZy5pbmZvKGBXaW5BcHBEcml2ZXIgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9LCBzaWduYWwgJHtzaWduYWx9YCk7XG4gICAgfSk7XG4gICAgbG9nLmluZm8oYFNwYXduaW5nICcke3RoaXMuZXhlY3V0YWJsZVBhdGh9JyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KDApO1xuICB9XG5cbiAgYXN5bmMgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cud2FybihgV2luQXBwRHJpdmVyIHByb2Nlc3Mgd2l0aCBQSUQgJHt0aGlzLnByb2MucGlkfSBjYW5ub3QgYmUgc3RvcHBlZC4gYCArXG4gICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgUlVOTklOR19QUk9DRVNTX0lEUyA9IFtdO1xucHJvY2Vzcy5vbmNlKCdleGl0JywgKCkgPT4ge1xuICBmb3IgKGNvbnN0IHBpZCBvZiBSVU5OSU5HX1BST0NFU1NfSURTKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IGB0YXNra2lsbC5leGUgL1BJRCAke3BpZH1gO1xuICAgIHRyeSB7XG4gICAgICBleGVjU3luYyhjb21tYW5kKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cud2FybihgV2luQXBwRHJpdmVyIHByb2Nlc3Mgd2l0aCBQSUQgJHtwaWR9IGNhbm5vdCBiZSBjbGVhbmVkIHVwLiBgICtcbiAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5jbGFzcyBXaW5BcHBEcml2ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5wcm94eVBvcnQgPSBvcHRzLnBvcnQ7XG5cbiAgICB0aGlzLnByb2Nlc3MgPSBudWxsO1xuICAgIHRoaXMucHJveHkgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKGNhcHMpIHtcbiAgICBjb25zdCBleGVjdXRhYmxlUGF0aCA9IGF3YWl0IGdldFdBREV4ZWN1dGFibGVQYXRoKCk7XG5cbiAgICB0aGlzLnByb2Nlc3MgPSBuZXcgV0FEUHJvY2Vzcyh7XG4gICAgICAvLyBYWFhZRCBUT0RPOiB3b3VsZCBiZSBiZXR0ZXIgaWYgV2luQXBwRHJpdmVyIGRpZG4ndCByZXF1aXJlIHBhc3NpbmcgaW4gL3dkL2h1YiBhcyBhIHBhcmFtXG4gICAgICBiYXNlOiBERUZBVUxUX0JBU0UsXG4gICAgICBwb3J0OiB0aGlzLnByb3h5UG9ydCxcbiAgICAgIGV4ZWN1dGFibGVQYXRoLFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMucHJvY2Vzcy5zdGFydCgpO1xuXG4gICAgdGhpcy5wcm94eSA9IG5ldyBXQURQcm94eSh7XG4gICAgICBzZXJ2ZXI6IERFRkFVTFRfSE9TVCxcbiAgICAgIHBvcnQ6IHRoaXMucHJvY2Vzcy5wb3J0LFxuICAgIH0pO1xuICAgIHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQgPSBmYWxzZTtcbiAgICB0aGlzLnByb2Nlc3MucHJvYy5vbignZXhpdCcsICgpID0+IHtcbiAgICAgIHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJveHkuY29tbWFuZCgnL3N0YXR1cycsICdHRVQnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJveHkuZGlkUHJvY2Vzc0V4aXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB3YWl0TXM6IFNUQVJUVVBfVElNRU9VVF9NUyxcbiAgICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgvQ29uZGl0aW9uIHVubWV0Ly50ZXN0KGUubWVzc2FnZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaW5BcHBEcml2ZXIgc2VydmVyIGlzIG5vdCBsaXN0ZW5pbmcgd2l0aGluICR7U1RBUlRVUF9USU1FT1VUX01TfW1zIHRpbWVvdXQuIGAgK1xuICAgICAgICAgIGBNYWtlIHN1cmUgaXQgY291bGQgYmUgc3RhcnRlZCBtYW51YWxseWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgY29uc3QgcGlkID0gdGhpcy5wcm9jZXNzLnByb2MucGlkO1xuICAgIFJVTk5JTkdfUFJPQ0VTU19JRFMucHVzaChwaWQpO1xuICAgIHRoaXMucHJvY2Vzcy5wcm9jLm9uKCdleGl0JywgKCkgPT4gdm9pZCBfLnB1bGwoUlVOTklOR19QUk9DRVNTX0lEUywgcGlkKSk7XG5cbiAgICBhd2FpdCB0aGlzLl9zdGFydFNlc3Npb24oY2Fwcyk7XG4gIH1cblxuICBhc3luYyBfc3RhcnRTZXNzaW9uIChkZXNpcmVkQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2Vzc2lvblRpbWVvdXQgPSBERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVNcbiAgICB9ID0gZGVzaXJlZENhcGFiaWxpdGllcztcbiAgICBsb2cuZGVidWcoYFN0YXJ0aW5nIFdpbkFwcERyaXZlciBzZXNzaW9uLiBXaWxsIHRpbWVvdXQgaW4gJyR7Y3JlYXRlU2Vzc2lvblRpbWVvdXR9JyBtcy5gKTtcbiAgICBsZXQgcmV0cnlJdGVyYXRpb24gPSAwO1xuICAgIGxldCBsYXN0RXJyb3I7XG5cbiAgICBjb25zdCBjb25kRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgcmV0cnlJdGVyYXRpb24rKztcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gZXJyb3IgPSAnJHtlcnJvci5tZXNzYWdlfScsIGF0dGVtcHQgPSAnJHtyZXRyeUl0ZXJhdGlvbn0nIGZyb20gJyR7dGhpcy5jcmVhdGVTZXNzaW9uUmV0cnl9J2ApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGNvbmRGbiwge1xuICAgICAgICB3YWl0TXM6IGNyZWF0ZVNlc3Npb25UaW1lb3V0LFxuICAgICAgICBpbnRlcnZhbE1zOiA1MDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHRpbWVvdXRFcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGB0aW1lb3V0RXJyb3Igd2FzICR7dGltZW91dEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgIHRocm93IChsYXN0RXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gd2l0aGluICR7Y3JlYXRlU2Vzc2lvblRpbWVvdXR9IG1zLmApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0b3AgKCkge1xuICAgIGlmICghdGhpcy5wcm9jZXNzPy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm94eT8uc2Vzc2lvbklkKSB7XG4gICAgICBsb2cuZGVidWcoJ0RlbGV0aW5nIFdpbkFwcERyaXZlciBzZXJ2ZXIgc2Vzc2lvbicpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm94eS5jb21tYW5kKGAvc2Vzc2lvbi8ke3RoaXMucHJveHk/LnNlc3Npb25JZH1gLCAnREVMRVRFJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYERpZCBub3QgZ2V0IGNvbmZpcm1hdGlvbiBXaW5BcHBEcml2ZXIgZGVsZXRlU2Vzc2lvbiB3b3JrZWQ7IGAgK1xuICAgICAgICAgIGBFcnJvciB3YXM6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wcm9jZXNzLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3h5LmNvbW1hbmQodXJsLCBtZXRob2QsIGJvZHkpO1xuICB9XG59XG5cbmV4cG9ydCB7IFdpbkFwcERyaXZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2luQXBwRHJpdmVyO1xuIl0sImZpbGUiOiJsaWIvd2luYXBwZHJpdmVyLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
