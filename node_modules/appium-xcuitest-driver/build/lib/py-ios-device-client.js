"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Pyidevice = void 0;

require("source-map-support/register");

var _teen_process = require("teen_process");

var _appiumSupport = require("appium-support");

var _logger = _interopRequireDefault(require("./logger"));

var _path = _interopRequireDefault(require("path"));

const BINARY_NAME = 'pyidevice';

class Pyidevice {
  constructor(udid) {
    this.udid = udid;
    this.binaryPath = null;
  }

  async assertExists(isStrict = true) {
    if (this.binaryPath) {
      return true;
    }

    try {
      this.binaryPath = await _appiumSupport.fs.which(BINARY_NAME);
      return true;
    } catch (e) {
      if (isStrict) {
        throw new Error(`${BINARY_NAME} binary cannot be found in PATH. ` + `Please make sure it is installed. Visit https://github.com/YueChen-C/py-ios-device for ` + `more details.`);
      }

      return false;
    }
  }

  async execute(args, opts = {}) {
    await this.assertExists();
    const {
      cwd,
      format = 'json',
      logStdout = false,
      asynchronous = false
    } = opts;
    const finalArgs = [...args, '--udid', this.udid];

    if (format) {
      finalArgs.push('--format', format);
    }

    const cmdStr = _appiumSupport.util.quote([this.binaryPath, ...finalArgs]);

    _logger.default.debug(`Executing ${cmdStr}`);

    try {
      if (asynchronous) {
        const result = new _teen_process.SubProcess(this.binaryPath, finalArgs, {
          cwd
        });
        await result.start(0);
        return result;
      }

      const result = await (0, _teen_process.exec)(this.binaryPath, finalArgs, {
        cwd
      });

      if (logStdout) {
        _logger.default.debug(`Command output: ${result.stdout}`);
      }

      return result;
    } catch (e) {
      throw new Error(`'${cmdStr}' failed. Original error: ${e.stderr || e.stdout || e.message}`);
    }
  }

  async listProfiles() {
    const {
      stdout
    } = await this.execute(['profiles', 'list']);
    return JSON.parse(stdout);
  }

  async installProfile({
    profilePath,
    payload
  } = {}) {
    if (!profilePath && !payload) {
      throw new Error('Either the full path to the profile or its payload must be provided');
    }

    let tmpRoot;
    let srcPath = profilePath;

    try {
      if (!srcPath) {
        tmpRoot = await _appiumSupport.tempDir.openDir();
        srcPath = _path.default.join(tmpRoot, 'cert.pem');
        await _appiumSupport.fs.writeFile(srcPath, payload, 'utf8');
      }

      await this.execute(['profiles', 'install', '--path', srcPath], {
        logStdout: true
      });
    } finally {
      if (tmpRoot) {
        await _appiumSupport.fs.rimraf(tmpRoot);
      }
    }
  }

  async removeProfile(name) {
    await this.execute(['profiles', 'remove', name], {
      logStdout: true
    });
  }

  async listCrashes() {
    const {
      stdout
    } = await this.execute(['crash', 'list']);
    return JSON.parse(stdout.replace(/'/g, '"')).filter(x => !['.', '..'].includes(x));
  }

  async exportCrash(name, dstFolder) {
    await this.execute(['crash', 'export', '--name', name], {
      logStdout: true,
      cwd: dstFolder
    });
  }

  async collectPcap(dstFile) {
    return await this.execute(['pcapd', dstFile], {
      format: null,
      asynchronous: true
    });
  }

}

exports.Pyidevice = Pyidevice;
var _default = Pyidevice;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9weS1pb3MtZGV2aWNlLWNsaWVudC5qcyJdLCJuYW1lcyI6WyJCSU5BUllfTkFNRSIsIlB5aWRldmljZSIsImNvbnN0cnVjdG9yIiwidWRpZCIsImJpbmFyeVBhdGgiLCJhc3NlcnRFeGlzdHMiLCJpc1N0cmljdCIsImZzIiwid2hpY2giLCJlIiwiRXJyb3IiLCJleGVjdXRlIiwiYXJncyIsIm9wdHMiLCJjd2QiLCJmb3JtYXQiLCJsb2dTdGRvdXQiLCJhc3luY2hyb25vdXMiLCJmaW5hbEFyZ3MiLCJwdXNoIiwiY21kU3RyIiwidXRpbCIsInF1b3RlIiwibG9nIiwiZGVidWciLCJyZXN1bHQiLCJTdWJQcm9jZXNzIiwic3RhcnQiLCJzdGRvdXQiLCJzdGRlcnIiLCJtZXNzYWdlIiwibGlzdFByb2ZpbGVzIiwiSlNPTiIsInBhcnNlIiwiaW5zdGFsbFByb2ZpbGUiLCJwcm9maWxlUGF0aCIsInBheWxvYWQiLCJ0bXBSb290Iiwic3JjUGF0aCIsInRlbXBEaXIiLCJvcGVuRGlyIiwicGF0aCIsImpvaW4iLCJ3cml0ZUZpbGUiLCJyaW1yYWYiLCJyZW1vdmVQcm9maWxlIiwibmFtZSIsImxpc3RDcmFzaGVzIiwicmVwbGFjZSIsImZpbHRlciIsIngiLCJpbmNsdWRlcyIsImV4cG9ydENyYXNoIiwiZHN0Rm9sZGVyIiwiY29sbGVjdFBjYXAiLCJkc3RGaWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUlBLE1BQU1BLFdBQVcsR0FBRyxXQUFwQjs7QUFFQSxNQUFNQyxTQUFOLENBQWdCO0FBQ2RDLEVBQUFBLFdBQVcsQ0FBRUMsSUFBRixFQUFRO0FBQ2pCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDRDs7QUFFaUIsUUFBWkMsWUFBWSxDQUFFQyxRQUFRLEdBQUcsSUFBYixFQUFtQjtBQUNuQyxRQUFJLEtBQUtGLFVBQVQsRUFBcUI7QUFDbkIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSTtBQUNGLFdBQUtBLFVBQUwsR0FBa0IsTUFBTUcsa0JBQUdDLEtBQUgsQ0FBU1IsV0FBVCxDQUF4QjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsQ0FHRSxPQUFPUyxDQUFQLEVBQVU7QUFDVixVQUFJSCxRQUFKLEVBQWM7QUFDWixjQUFNLElBQUlJLEtBQUosQ0FBVyxHQUFFVixXQUFZLG1DQUFmLEdBQ2IseUZBRGEsR0FFYixlQUZHLENBQU47QUFHRDs7QUFDRCxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVZLFFBQVBXLE9BQU8sQ0FBRUMsSUFBRixFQUFRQyxJQUFJLEdBQUcsRUFBZixFQUFtQjtBQUM5QixVQUFNLEtBQUtSLFlBQUwsRUFBTjtBQUNBLFVBQU07QUFDSlMsTUFBQUEsR0FESTtBQUVKQyxNQUFBQSxNQUFNLEdBQUcsTUFGTDtBQUdKQyxNQUFBQSxTQUFTLEdBQUcsS0FIUjtBQUlKQyxNQUFBQSxZQUFZLEdBQUc7QUFKWCxRQUtGSixJQUxKO0FBT0EsVUFBTUssU0FBUyxHQUFHLENBQUMsR0FBR04sSUFBSixFQUFVLFFBQVYsRUFBb0IsS0FBS1QsSUFBekIsQ0FBbEI7O0FBQ0EsUUFBSVksTUFBSixFQUFZO0FBQ1ZHLE1BQUFBLFNBQVMsQ0FBQ0MsSUFBVixDQUFlLFVBQWYsRUFBMkJKLE1BQTNCO0FBQ0Q7O0FBQ0QsVUFBTUssTUFBTSxHQUFHQyxvQkFBS0MsS0FBTCxDQUFXLENBQUMsS0FBS2xCLFVBQU4sRUFBa0IsR0FBR2MsU0FBckIsQ0FBWCxDQUFmOztBQUNBSyxvQkFBSUMsS0FBSixDQUFXLGFBQVlKLE1BQU8sRUFBOUI7O0FBQ0EsUUFBSTtBQUNGLFVBQUlILFlBQUosRUFBa0I7QUFDaEIsY0FBTVEsTUFBTSxHQUFHLElBQUlDLHdCQUFKLENBQWUsS0FBS3RCLFVBQXBCLEVBQWdDYyxTQUFoQyxFQUEyQztBQUFDSixVQUFBQTtBQUFELFNBQTNDLENBQWY7QUFDQSxjQUFNVyxNQUFNLENBQUNFLEtBQVAsQ0FBYSxDQUFiLENBQU47QUFDQSxlQUFPRixNQUFQO0FBQ0Q7O0FBQ0QsWUFBTUEsTUFBTSxHQUFHLE1BQU0sd0JBQUssS0FBS3JCLFVBQVYsRUFBc0JjLFNBQXRCLEVBQWlDO0FBQUNKLFFBQUFBO0FBQUQsT0FBakMsQ0FBckI7O0FBQ0EsVUFBSUUsU0FBSixFQUFlO0FBQ2JPLHdCQUFJQyxLQUFKLENBQVcsbUJBQWtCQyxNQUFNLENBQUNHLE1BQU8sRUFBM0M7QUFDRDs7QUFDRCxhQUFPSCxNQUFQO0FBQ0QsS0FYRCxDQVdFLE9BQU9oQixDQUFQLEVBQVU7QUFDVixZQUFNLElBQUlDLEtBQUosQ0FBVyxJQUFHVSxNQUFPLDZCQUE0QlgsQ0FBQyxDQUFDb0IsTUFBRixJQUFZcEIsQ0FBQyxDQUFDbUIsTUFBZCxJQUF3Qm5CLENBQUMsQ0FBQ3FCLE9BQVEsRUFBbkYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRWlCLFFBQVpDLFlBQVksR0FBSTtBQUNwQixVQUFNO0FBQUNILE1BQUFBO0FBQUQsUUFBVyxNQUFNLEtBQUtqQixPQUFMLENBQWEsQ0FBQyxVQUFELEVBQWEsTUFBYixDQUFiLENBQXZCO0FBQ0EsV0FBT3FCLElBQUksQ0FBQ0MsS0FBTCxDQUFXTCxNQUFYLENBQVA7QUFDRDs7QUFFbUIsUUFBZE0sY0FBYyxDQUFFO0FBQUNDLElBQUFBLFdBQUQ7QUFBY0MsSUFBQUE7QUFBZCxNQUF5QixFQUEzQixFQUErQjtBQUNqRCxRQUFJLENBQUNELFdBQUQsSUFBZ0IsQ0FBQ0MsT0FBckIsRUFBOEI7QUFDNUIsWUFBTSxJQUFJMUIsS0FBSixDQUFVLHFFQUFWLENBQU47QUFDRDs7QUFFRCxRQUFJMkIsT0FBSjtBQUNBLFFBQUlDLE9BQU8sR0FBR0gsV0FBZDs7QUFDQSxRQUFJO0FBQ0YsVUFBSSxDQUFDRyxPQUFMLEVBQWM7QUFDWkQsUUFBQUEsT0FBTyxHQUFHLE1BQU1FLHVCQUFRQyxPQUFSLEVBQWhCO0FBQ0FGLFFBQUFBLE9BQU8sR0FBR0csY0FBS0MsSUFBTCxDQUFVTCxPQUFWLEVBQW1CLFVBQW5CLENBQVY7QUFDQSxjQUFNOUIsa0JBQUdvQyxTQUFILENBQWFMLE9BQWIsRUFBc0JGLE9BQXRCLEVBQStCLE1BQS9CLENBQU47QUFDRDs7QUFDRCxZQUFNLEtBQUt6QixPQUFMLENBQWEsQ0FBQyxVQUFELEVBQWEsU0FBYixFQUF3QixRQUF4QixFQUFrQzJCLE9BQWxDLENBQWIsRUFBeUQ7QUFDN0R0QixRQUFBQSxTQUFTLEVBQUU7QUFEa0QsT0FBekQsQ0FBTjtBQUdELEtBVEQsU0FTVTtBQUNSLFVBQUlxQixPQUFKLEVBQWE7QUFDWCxjQUFNOUIsa0JBQUdxQyxNQUFILENBQVVQLE9BQVYsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFa0IsUUFBYlEsYUFBYSxDQUFFQyxJQUFGLEVBQVE7QUFDekIsVUFBTSxLQUFLbkMsT0FBTCxDQUFhLENBQUMsVUFBRCxFQUFhLFFBQWIsRUFBdUJtQyxJQUF2QixDQUFiLEVBQTJDO0FBQUM5QixNQUFBQSxTQUFTLEVBQUU7QUFBWixLQUEzQyxDQUFOO0FBQ0Q7O0FBRWdCLFFBQVgrQixXQUFXLEdBQUk7QUFDbkIsVUFBTTtBQUFDbkIsTUFBQUE7QUFBRCxRQUFXLE1BQU0sS0FBS2pCLE9BQUwsQ0FBYSxDQUFDLE9BQUQsRUFBVSxNQUFWLENBQWIsQ0FBdkI7QUFDQSxXQUFPcUIsSUFBSSxDQUFDQyxLQUFMLENBQVdMLE1BQU0sQ0FBQ29CLE9BQVAsQ0FBZSxJQUFmLEVBQXFCLEdBQXJCLENBQVgsRUFBc0NDLE1BQXRDLENBQThDQyxDQUFELElBQU8sQ0FBQyxDQUFDLEdBQUQsRUFBTSxJQUFOLEVBQVlDLFFBQVosQ0FBcUJELENBQXJCLENBQXJELENBQVA7QUFDRDs7QUFFZ0IsUUFBWEUsV0FBVyxDQUFFTixJQUFGLEVBQVFPLFNBQVIsRUFBbUI7QUFDbEMsVUFBTSxLQUFLMUMsT0FBTCxDQUFhLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsUUFBcEIsRUFBOEJtQyxJQUE5QixDQUFiLEVBQWtEO0FBQ3REOUIsTUFBQUEsU0FBUyxFQUFFLElBRDJDO0FBR3RERixNQUFBQSxHQUFHLEVBQUV1QztBQUhpRCxLQUFsRCxDQUFOO0FBS0Q7O0FBRWdCLFFBQVhDLFdBQVcsQ0FBRUMsT0FBRixFQUFXO0FBQzFCLFdBQU8sTUFBTSxLQUFLNUMsT0FBTCxDQUFhLENBQUMsT0FBRCxFQUFVNEMsT0FBVixDQUFiLEVBQWlDO0FBQzVDeEMsTUFBQUEsTUFBTSxFQUFFLElBRG9DO0FBRTVDRSxNQUFBQSxZQUFZLEVBQUU7QUFGOEIsS0FBakMsQ0FBYjtBQUlEOztBQXpHYTs7O2VBNkdEaEIsUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgZnMsIHV0aWwsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vWXVlQ2hlbi1DL3B5LWlvcy1kZXZpY2VcblxuY29uc3QgQklOQVJZX05BTUUgPSAncHlpZGV2aWNlJztcblxuY2xhc3MgUHlpZGV2aWNlIHtcbiAgY29uc3RydWN0b3IgKHVkaWQpIHtcbiAgICB0aGlzLnVkaWQgPSB1ZGlkO1xuICAgIHRoaXMuYmluYXJ5UGF0aCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBhc3NlcnRFeGlzdHMgKGlzU3RyaWN0ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmJpbmFyeVBhdGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmJpbmFyeVBhdGggPSBhd2FpdCBmcy53aGljaChCSU5BUllfTkFNRSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0JJTkFSWV9OQU1FfSBiaW5hcnkgY2Fubm90IGJlIGZvdW5kIGluIFBBVEguIGAgK1xuICAgICAgICAgIGBQbGVhc2UgbWFrZSBzdXJlIGl0IGlzIGluc3RhbGxlZC4gVmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL1l1ZUNoZW4tQy9weS1pb3MtZGV2aWNlIGZvciBgICtcbiAgICAgICAgICBgbW9yZSBkZXRhaWxzLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUgKGFyZ3MsIG9wdHMgPSB7fSkge1xuICAgIGF3YWl0IHRoaXMuYXNzZXJ0RXhpc3RzKCk7XG4gICAgY29uc3Qge1xuICAgICAgY3dkLFxuICAgICAgZm9ybWF0ID0gJ2pzb24nLFxuICAgICAgbG9nU3Rkb3V0ID0gZmFsc2UsXG4gICAgICBhc3luY2hyb25vdXMgPSBmYWxzZSxcbiAgICB9ID0gb3B0cztcblxuICAgIGNvbnN0IGZpbmFsQXJncyA9IFsuLi5hcmdzLCAnLS11ZGlkJywgdGhpcy51ZGlkXTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBmaW5hbEFyZ3MucHVzaCgnLS1mb3JtYXQnLCBmb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBjbWRTdHIgPSB1dGlsLnF1b3RlKFt0aGlzLmJpbmFyeVBhdGgsIC4uLmZpbmFsQXJnc10pO1xuICAgIGxvZy5kZWJ1ZyhgRXhlY3V0aW5nICR7Y21kU3RyfWApO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXN5bmNocm9ub3VzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTdWJQcm9jZXNzKHRoaXMuYmluYXJ5UGF0aCwgZmluYWxBcmdzLCB7Y3dkfSk7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5zdGFydCgwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcnlQYXRoLCBmaW5hbEFyZ3MsIHtjd2R9KTtcbiAgICAgIGlmIChsb2dTdGRvdXQpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBDb21tYW5kIG91dHB1dDogJHtyZXN1bHQuc3Rkb3V0fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2NtZFN0cn0nIGZhaWxlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5zdGRvdXQgfHwgZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxpc3RQcm9maWxlcyAoKSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCB0aGlzLmV4ZWN1dGUoWydwcm9maWxlcycsICdsaXN0J10pO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dCk7XG4gIH1cblxuICBhc3luYyBpbnN0YWxsUHJvZmlsZSAoe3Byb2ZpbGVQYXRoLCBwYXlsb2FkfSA9IHt9KSB7XG4gICAgaWYgKCFwcm9maWxlUGF0aCAmJiAhcGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgdGhlIGZ1bGwgcGF0aCB0byB0aGUgcHJvZmlsZSBvciBpdHMgcGF5bG9hZCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IHRtcFJvb3Q7XG4gICAgbGV0IHNyY1BhdGggPSBwcm9maWxlUGF0aDtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzcmNQYXRoKSB7XG4gICAgICAgIHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgICAgICAgc3JjUGF0aCA9IHBhdGguam9pbih0bXBSb290LCAnY2VydC5wZW0nKTtcbiAgICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHNyY1BhdGgsIHBheWxvYWQsICd1dGY4Jyk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoWydwcm9maWxlcycsICdpbnN0YWxsJywgJy0tcGF0aCcsIHNyY1BhdGhdLCB7XG4gICAgICAgIGxvZ1N0ZG91dDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0bXBSb290KSB7XG4gICAgICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyByZW1vdmVQcm9maWxlIChuYW1lKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFsncHJvZmlsZXMnLCAncmVtb3ZlJywgbmFtZV0sIHtsb2dTdGRvdXQ6IHRydWV9KTtcbiAgfVxuXG4gIGFzeW5jIGxpc3RDcmFzaGVzICgpIHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShbJ2NyYXNoJywgJ2xpc3QnXSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3Rkb3V0LnJlcGxhY2UoLycvZywgJ1wiJykpLmZpbHRlcigoeCkgPT4gIVsnLicsICcuLiddLmluY2x1ZGVzKHgpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydENyYXNoIChuYW1lLCBkc3RGb2xkZXIpIHtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoWydjcmFzaCcsICdleHBvcnQnLCAnLS1uYW1lJywgbmFtZV0sIHtcbiAgICAgIGxvZ1N0ZG91dDogdHJ1ZSxcbiAgICAgIC8vIFRoZSB0b29sIGV4cG9ydHMgY3Jhc2ggcmVwb3J0cyB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpclxuICAgICAgY3dkOiBkc3RGb2xkZXJcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNvbGxlY3RQY2FwIChkc3RGaWxlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZShbJ3BjYXBkJywgZHN0RmlsZV0sIHtcbiAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgIGFzeW5jaHJvbm91czogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFB5aWRldmljZSB9O1xuZXhwb3J0IGRlZmF1bHQgUHlpZGV2aWNlO1xuIl0sImZpbGUiOiJsaWIvcHktaW9zLWRldmljZS1jbGllbnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
